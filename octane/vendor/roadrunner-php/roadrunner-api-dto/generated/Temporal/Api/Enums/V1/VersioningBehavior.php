<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: temporal/api/enums/v1/workflow.proto

namespace Temporal\Api\Enums\V1;

use UnexpectedValueException;

/**
 * Protobuf type <code>temporal.api.enums.v1.VersioningBehavior</code>
 */
class VersioningBehavior
{
    /**
     * Workflow execution is unversioned. This is the legacy behavior. An unversioned workflow's
     * task may go to any unversioned worker who is polling for the task queue.
     *
     * Generated from protobuf enum <code>VERSIONING_BEHAVIOR_UNSPECIFIED = 0;</code>
     */
    const VERSIONING_BEHAVIOR_UNSPECIFIED = 0;
    /**
     * Workflow will be pinned to the current deployment until completion. Can be overridden
     * explicitly via `UpdateWorkflowExecutionOptions` API.
     * Activities of `PINNED` workflows are sent to the same deployment. Exception to this would be
     * when the activity task queue workers are not present in the workflows deployment, in which
     * case the activity will be sent to the current deployment of its own task queue.
     *
     * Generated from protobuf enum <code>VERSIONING_BEHAVIOR_PINNED = 1;</code>
     */
    const VERSIONING_BEHAVIOR_PINNED = 1;
    /**
     * Workflow will automatically move to the current deployment of its task queue when the next
     * workflow task is dispatched.
     * Activities of `AUTO_UPGRADE` workflows are sent to the current deployment of the workflow
     * execution based on the last completed workflow task. Exception to this would be when the
     * activity task queue workers are not present in the workflow's deployment, in which case the
     * activity will be sent to the current deployment of its own task queue.
     * Workflows stuck on a backlogged activity will still auto-upgrade if the default deployment
     * of their task queue changes, without having to wait for the backlogged activity to complete
     * on the old deployment.
     *
     * Generated from protobuf enum <code>VERSIONING_BEHAVIOR_AUTO_UPGRADE = 2;</code>
     */
    const VERSIONING_BEHAVIOR_AUTO_UPGRADE = 2;

    private static $valueToName = [
        self::VERSIONING_BEHAVIOR_UNSPECIFIED => 'VERSIONING_BEHAVIOR_UNSPECIFIED',
        self::VERSIONING_BEHAVIOR_PINNED => 'VERSIONING_BEHAVIOR_PINNED',
        self::VERSIONING_BEHAVIOR_AUTO_UPGRADE => 'VERSIONING_BEHAVIOR_AUTO_UPGRADE',
    ];

    public static function name($value)
    {
        if (!isset(self::$valueToName[$value])) {
            throw new UnexpectedValueException(sprintf(
                    'Enum %s has no name defined for value %s', __CLASS__, $value));
        }
        return self::$valueToName[$value];
    }


    public static function value($name)
    {
        $const = __CLASS__ . '::' . strtoupper($name);
        if (!defined($const)) {
            throw new UnexpectedValueException(sprintf(
                    'Enum %s has no value defined for name %s', __CLASS__, $name));
        }
        return constant($const);
    }
}

